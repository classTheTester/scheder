<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MorphCast Emotion Analysis Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }ml
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .camera-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .results-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            overflow-y: auto;
            max-height: 80vh;
        }
        
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .camera-container {
            width: 100%;
            height: 300px;
            background-color: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .camera-placeholder {
            text-align: center;
            color: #ccc;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .camera-placeholder i {
            font-size: 64px;
            margin-bottom: 15px;
            display: block;
        }
        
        .permission-btn {
            display: block;
            width: 100%;
            padding: 15px;
            background: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }
        
        .permission-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .permission-btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            opacity: 0.8;
        }
        
        .metric-value {
            font-size: 1.8rem;
            font-weight: bold;
        }
        
        .emotion-bars {
            margin-bottom: 20px;
        }
        
        .emotion {
            margin-bottom: 15px;
        }
        
        .emotion-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .emotion-bar {
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .emotion-fill {
            height: 100%;
            background: linear-gradient(to right, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
            border-radius: 5px;
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .feature-section {
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }
        
        .feature-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .feature-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .feature-item {
            margin-bottom: 8px;
        }
        
        .feature-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .feature-value {
            font-weight: bold;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .privacy-note {
            margin-top: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
            text-align: center;
        }
        
        .alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .alert-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .alert-popup {
            background: linear-gradient(to bottom, #2c3e50, #4a6491);
            border-radius: 15px;
            padding: 30px;
            width: 90%;
            max-width: 450px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            transform: translateY(20px);
            transition: transform 0.4s ease;
        }
        
        .alert-overlay.active .alert-popup {
            transform: translateY(0);
        }
        
        .alert-icon {
            font-size: 60px;
            margin-bottom: 20px;
        }
        
        .alert-title {
            font-size: 24px;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .alert-message {
            font-size: 18px;
            margin-bottom: 25px;
            line-height: 1.5;
            color: #e0e0e0;
        }
        
        .alert-button {
            background: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .alert-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .results-section {
                max-height: none;
            }
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .feature-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>MorphCast Emotion Analysis Dashboard</h1>
            <p class="subtitle">Comprehensive facial analysis with all available features</p>
        </header>
        
        <div class="dashboard">
            <div class="camera-section">
                <h2 class="section-title">Camera Feed</h2>
                <div class="camera-container">
                    <video id="videoElement" autoplay playsinline></video>
                    <div class="camera-placeholder" id="cameraPlaceholder">
                        <i>📷</i>
                        <p>Camera access required</p>
                    </div>
                </div>
                <button id="permissionBtn" class="permission-btn">Allow Camera Access</button>
                <p class="privacy-note">Your data is processed locally and never stored on our servers</p>
                
                <div class="learning-controls" style="margin-top: 20px;">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                        <input type="text" id="courseIdInput" placeholder="Course ID (e.g., MATH101)" style="padding: 8px; border: 1px solid #ccc; border-radius: 5px; flex: 1; min-width: 150px;">
                        <select id="sessionTypeSelect" style="padding: 8px; border: 1px solid #ccc; border-radius: 5px;">
                            <option value="learning">Learning Session</option>
                            <option value="assessment">Assessment</option>
                            <option value="break">Break</option>
                        </select>
                        <button id="startSessionBtn" class="data-btn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Start Session</button>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button id="saveDataBtn" class="data-btn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Save Data</button>
                        <button id="exportDataBtn" class="data-btn" style="padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer;">Export JSON</button>
                        <button id="debugDataBtn" class="data-btn" style="padding: 8px 16px; background: #9C27B0; color: white; border: none; border-radius: 5px; cursor: pointer;">Debug Data</button>
                    </div>
                </div>
                
                
                <div class="status" id="statusMessage">
                    <p>Waiting for camera access to begin analysis...</p>
                </div>
            </div>
            
            <div class="results-section">
                <h2 class="section-title">Analysis Results</h2>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-title">Attention</div>
                        <div class="metric-value" id="attentionValue">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Arousal</div>
                        <div class="metric-value" id="arousalValue">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Valence</div>
                        <div class="metric-value" id="valenceValue">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Positivity</div>
                        <div class="metric-value" id="positivityValue">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Wish</div>
                        <div class="metric-value" id="wishValue">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Faces Detected</div>
                        <div class="metric-value" id="facesValue">-</div>
                    </div>
                </div>
                
                <div class="emotion-bars">
                    <h3 class="feature-title">Emotions</h3>
                    <div class="emotion">
                        <div class="emotion-label">
                            <span>Happiness</span>
                            <span id="happinessValue">0%</span>
                        </div>
                        <div class="emotion-bar">
                            <div class="emotion-fill" id="happinessBar"></div>
                        </div>
                    </div>
                    <div class="emotion">
                        <div class="emotion-label">
                            <span>Sadness</span>
                            <span id="sadnessValue">0%</span>
                        </div>
                        <div class="emotion-bar">
                            <div class="emotion-fill" id="sadnessBar"></div>
                        </div>
                    </div>
                    <div class="emotion">
                        <div class="emotion-label">
                            <span>Anger</span>
                            <span id="angerValue">0%</span>
                        </div>
                        <div class="emotion-bar">
                            <div class="emotion-fill" id="angerBar"></div>
                        </div>
                    </div>
                    <div class="emotion">
                        <div class="emotion-label">
                            <span>Surprise</span>
                            <span id="surpriseValue">0%</span>
                        </div>
                        <div class="emotion-bar">
                            <div class="emotion-fill" id="surpriseBar"></div>
                        </div>
                    </div>
                    <div class="emotion">
                        <div class="emotion-label">
                            <span>Fear</span>
                            <span id="fearValue">0%</span>
                        </div>
                        <div class="emotion-bar">
                            <div class="emotion-fill" id="fearBar"></div>
                        </div>
                    </div>
                    <div class="emotion">
                        <div class="emotion-label">
                            <span>Disgust</span>
                            <span id="disgustValue">0%</span>
                        </div>
                        <div class="emotion-bar">
                            <div class="emotion-fill" id="disgustBar"></div>
                        </div>
                    </div>
                    <div class="emotion">
                        <div class="emotion-label">
                            <span>Neutral</span>
                            <span id="neutralValue">0%</span>
                        </div>
                        <div class="emotion-bar">
                            <div class="emotion-fill" id="neutralBar"></div>
                        </div>
                    </div>
                </div>
                
                <div class="feature-section">
                    <h3 class="feature-title">Face Details</h3>
                    <div class="feature-content">
                        <div class="feature-item">
                            <div class="feature-label">Age</div>
                            <div class="feature-value" id="ageValue">-</div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-label">Gender</div>
                            <div class="feature-value" id="genderValue">-</div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-label">Pitch</div>
                            <div class="feature-value" id="pitchValue">-</div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-label">Roll</div>
                            <div class="feature-value" id="rollValue">-</div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-label">Yaw</div>
                            <div class="feature-value" id="yawValue">-</div>
                        </div>
                    </div>
                </div>
                
                <div class="feature-section">
                    <h3 class="feature-title">Age Probabilities</h3>
                    <div class="feature-content">
                        <div class="feature-item">
                            <div class="feature-label">Under 18</div>
                            <div class="feature-value" id="ageUnder18">-</div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-label">18-35</div>
                            <div class="feature-value" id="age18to35">-</div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-label">35-51</div>
                            <div class="feature-value" id="age35to51">-</div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-label">Over 51</div>
                            <div class="feature-value" id="ageOver51">-</div>
                        </div>
                    </div>
                </div>
                
                <div class="feature-section">
                    <h3 class="feature-title">Gender Probabilities</h3>
                    <div class="feature-content">
                        <div class="feature-item">
                            <div class="feature-label">Male</div>
                            <div class="feature-value" id="genderMale">-</div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-label">Female</div>
                            <div class="feature-value" id="genderFemale">-</div>
                        </div>
                    </div>
                </div>
                
                <div class="feature-section">
                    <h3 class="feature-title">Selected Facial Features</h3>
                    <div class="feature-content" id="facialFeatures">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Alert Popup -->
    <div class="alert-overlay" id="alertOverlay">
        <div class="alert-popup">
            <div class="alert-icon" id="alertIcon">⚠️</div>
            <h2 class="alert-title" id="alertTitle">Alert</h2>
            <p class="alert-message" id="alertMessage">This is an alert message</p>
            <button class="alert-button" id="alertButton">OK</button>
        </div>
    </div>

    <!-- MorphCast SDK -->
    <script src="https://sdk.morphcast.com/mphtools/v1.1/mphtools.js" data-config="cameraPrivacyPopup, compatibilityUI, compatibilityAutoCheck"></script>
    <script src="https://ai-sdk.morphcast.com/v1.16/ai-sdk.js"></script>
    <script src="https://sdk.morphcast.com/emotion-statistics/v1.0-beta/script.js"></script>
    <script type="module" src="https://sdk.morphcast.com/mphoverlay/v0.1/mph-ai-overlay.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const permissionBtn = document.getElementById('permissionBtn');
            const videoElement = document.getElementById('videoElement');
            const cameraPlaceholder = document.getElementById('cameraPlaceholder');
            const statusMessage = document.getElementById('statusMessage');
            const alertOverlay = document.getElementById('alertOverlay');
            const alertIcon = document.getElementById('alertIcon');
            const alertTitle = document.getElementById('alertTitle');
            const alertMessage = document.getElementById('alertMessage');
            const alertButton = document.getElementById('alertButton');
            const facialFeaturesContainer = document.getElementById('facialFeatures');
            
            let isCameraActive = false;
            let stream = null;
            let startFunction = null;
            let stopFunction = null;
            let currentAlert = null;
            let recomputeTimer = null;
            
            // MorphCast Statistics Configuration
            const statsConfig = {
                sendDatainterval: 5000,
                tickInterval: 1000,
                stopAfter: 900000,
                licenseKey: "sk75ffec7bbf60d0e38bea6af5f5e2fbd680b0c023201b"
            };
            let statisticsUploader = null;
            
            // Learning-focused data collection storage
            let collectedData = {
                // Raw MorphCast data only
                faceAttention: [],
                faceArousalValence: [],
                faceEmotion: [],
                faceDetector: [],
                
                // Session tracking
                sessionInfo: {
                    startTime: null,
                    endTime: null,
                    courseId: null,
                    sessionType: 'learning'
                }
            };
            
            // Auto-save configuration
            const autoSaveConfig = {
                enabled: true,
                interval: 60000, // Save every 60 seconds (reduced frequency)
                maxDataPoints: 5000, // Maximum data points to keep in memory (reduced)
                maxEntriesPerModule: 200 // Maximum entries per module
            };
            let autoSaveTimer = null;
            
            // Configure privacy popup text
            MphTools.CameraPrivacyPopup.setText({
                "title": "Allow us to use your camera",
                "description": "This experience is designed to be viewed with your camera on. The next screen will ask your consent to access data from your camera.",
                "url": "https://example.com/privacy-policy"
            });
            
            // Function to show alert popup
            function showAlert(title, message, icon = '⚠️', autoHide = true, hideButton = false) {
                if (currentAlert) {
                    clearTimeout(currentAlert);
                    currentAlert = null;
                }
                alertIcon.textContent = icon;
                alertTitle.textContent = title;
                alertMessage.textContent = message;
                alertOverlay.classList.add('active');
                
                // Show/hide button based on hideButton parameter
                if (hideButton) {
                    alertButton.style.display = 'none';
                } else {
                    alertButton.style.display = 'block';
                }
                
                // Auto-hide after 5 seconds only if autoHide is true
                if (autoHide) {
                    currentAlert = setTimeout(hideAlert, 5000);
                }
            }
            
            // Function to hide alert popup
            function hideAlert() {
                alertOverlay.classList.remove('active');
                if (currentAlert) {
                    clearTimeout(currentAlert);
                    currentAlert = null;
                }
            }
            
            // Global audio context for reuse
            let globalAudioContext = null;
            
            // Function to play sound when no faces detected
            function playNoFaceSound() {
                try {
                    // Create or resume audio context
                    if (!globalAudioContext) {
                        globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Resume audio context if suspended (required by browsers)
                    if (globalAudioContext.state === 'suspended') {
                        globalAudioContext.resume().then(() => {
                            playPingSound();
                        }).catch(error => {
                            console.log('Could not resume audio context:', error);
                            playFallbackSound();
                        });
                    } else {
                        playPingSound();
                    }
                    
                } catch (error) {
                    console.log('Could not create audio context:', error);
                    playFallbackSound();
                }
            }
            
            // Function to play the actual ping sound
            function playPingSound() {
                try {
                    // Create oscillator for ping sound
                    const oscillator = globalAudioContext.createOscillator();
                    const gainNode = globalAudioContext.createGain();
                    
                    // Connect oscillator to gain node to audio context
                    oscillator.connect(gainNode);
                    gainNode.connect(globalAudioContext.destination);
                    
                    // Configure ping sound (800Hz frequency, short duration)
                    oscillator.frequency.setValueAtTime(800, globalAudioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    // Set volume envelope (quick attack, quick decay)
                    gainNode.gain.setValueAtTime(0, globalAudioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, globalAudioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, globalAudioContext.currentTime + 0.2);
                    
                    // Play the sound
                    oscillator.start(globalAudioContext.currentTime);
                    oscillator.stop(globalAudioContext.currentTime + 0.2);
                    
                } catch (error) {
                    console.log('Could not play ping sound:', error);
                    playFallbackSound();
                }
            }
            
            // Fallback sound function
            function playFallbackSound() {
                try {
                    const audio = new Audio();
                    audio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjuBzvLZizEIHm7A7+OZURE='; // Short beep sound
                    audio.play().catch(() => {
                        console.log('Audio playback not supported');
                    });
                } catch (fallbackError) {
                    console.log('Fallback audio also failed:', fallbackError);
                }
            }
            
            // Function to collect raw MorphCast data
            function collectLearningData(moduleName, data) {
                const timestamp = new Date().toISOString();
                
                // Store raw data with timestamp
                const dataEntry = {
                    timestamp: timestamp,
                    data: data
                };
                
                switch (moduleName) {
                    case 'FACE_ATTENTION':
                        collectedData.faceAttention.push(dataEntry);
                        break;
                    case 'FACE_AROUSAL_VALENCE':
                        collectedData.faceArousalValence.push(dataEntry);
                        break;
                    case 'FACE_EMOTION':
                        collectedData.faceEmotion.push(dataEntry);
                        break;
                    case 'FACE_DETECTOR':
                        collectedData.faceDetector.push(dataEntry);
                        break;
                }
                
                // Clean up old data if we exceed max data points
                if (collectedData.faceAttention.length + collectedData.faceArousalValence.length + 
                    collectedData.faceEmotion.length + collectedData.faceDetector.length > autoSaveConfig.maxDataPoints) {
                    cleanupOldData();
                }
            }
            
            
            // Function to start a learning session
            function startLearningSession() {
                const courseId = document.getElementById('courseIdInput').value.trim();
                const sessionType = document.getElementById('sessionTypeSelect').value;
                
                if (!courseId) {
                    showAlert('Course ID Required', 'Please enter a Course ID to start the session.', '⚠️');
                    return;
                }
                
                // Clear previous data
                clearData();
                
                // Set session info
                collectedData.sessionInfo.courseId = courseId;
                collectedData.sessionInfo.sessionType = sessionType;
                collectedData.sessionInfo.startTime = new Date().toISOString();
                
                showAlert('Session Started', `Started ${sessionType} for course: ${courseId}`, '📚');
                
                // Start auto-save
                startAutoSave();
            }
            
            
            // Function to get current UI values that are displayed on the website
            function getCurrentUIValues() {
                return {
                    // Metrics
                    attention: document.getElementById('attentionValue').textContent,
                    arousal: document.getElementById('arousalValue').textContent,
                    valence: document.getElementById('valenceValue').textContent,
                    positivity: document.getElementById('positivityValue').textContent,
                    wish: document.getElementById('wishValue').textContent,
                    faces: document.getElementById('facesValue').textContent,
                    
                    // Emotions
                    happiness: document.getElementById('happinessValue').textContent,
                    sadness: document.getElementById('sadnessValue').textContent,
                    anger: document.getElementById('angerValue').textContent,
                    surprise: document.getElementById('surpriseValue').textContent,
                    fear: document.getElementById('fearValue').textContent,
                    disgust: document.getElementById('disgustValue').textContent,
                    neutral: document.getElementById('neutralValue').textContent,
                    
                    // Face Details
                    age: document.getElementById('ageValue').textContent,
                    gender: document.getElementById('genderValue').textContent,
                    pitch: document.getElementById('pitchValue').textContent,
                    roll: document.getElementById('rollValue').textContent,
                    yaw: document.getElementById('yawValue').textContent,
                    
                    // Age Probabilities
                    ageUnder18: document.getElementById('ageUnder18').textContent,
                    age18to35: document.getElementById('age18to35').textContent,
                    age35to51: document.getElementById('age35to51').textContent,
                    ageOver51: document.getElementById('ageOver51').textContent,
                    
                    // Gender Probabilities
                    genderMale: document.getElementById('genderMale').textContent,
                    genderFemale: document.getElementById('genderFemale').textContent
                };
            }
            
            // Function to cleanup old data to prevent memory issues
            function cleanupOldData() {
                const maxEntries = autoSaveConfig.maxEntriesPerModule;
                
                if (collectedData.faceAttention.length > maxEntries) {
                    collectedData.faceAttention = collectedData.faceAttention.slice(-maxEntries);
                }
                if (collectedData.faceArousalValence.length > maxEntries) {
                    collectedData.faceArousalValence = collectedData.faceArousalValence.slice(-maxEntries);
                }
                if (collectedData.faceEmotion.length > maxEntries) {
                    collectedData.faceEmotion = collectedData.faceEmotion.slice(-maxEntries);
                }
                if (collectedData.faceDetector.length > maxEntries) {
                    collectedData.faceDetector = collectedData.faceDetector.slice(-maxEntries);
                }
            }
            
            // Function to save data to localStorage
            function saveDataToLocal() {
                try {
                    console.log('=== SAVING DATA ===');
                    console.log('Current data points:', collectedData.sessionInfo.totalDataPoints);
                    
                    const sessionId = `morphcast_session_${new Date().toISOString().split('T')[0]}_${Date.now()}`;
                    
                    // Create a compressed version of the data
                    const compressedData = compressDataForStorage(collectedData);
                    const dataToSave = {
                        ...compressedData,
                        sessionInfo: {
                            ...compressedData.sessionInfo,
                            endTime: new Date().toISOString(),
                            sessionId: sessionId
                        }
                    };
                    
                    const jsonString = JSON.stringify(dataToSave);
                    console.log('JSON string length:', jsonString.length);
                    
                    // Check if data is too large for localStorage (5MB limit)
                    if (jsonString.length > 4 * 1024 * 1024) { // 4MB safety margin
                        console.warn('Data too large for localStorage, saving summary only');
                        const summaryData = createDataSummary(collectedData);
                        const summaryJson = JSON.stringify(summaryData);
                        localStorage.setItem(sessionId, summaryJson);
                        localStorage.setItem('morphcast_latest_session', summaryJson);
                        console.log('Summary data saved to localStorage:', sessionId);
                        return sessionId;
                    }
                    
                    localStorage.setItem(sessionId, jsonString);
                    localStorage.setItem('morphcast_latest_session', jsonString);
                    
                    console.log('Data saved to localStorage:', sessionId);
                    return sessionId;
                } catch (error) {
                    console.error('Error saving data to localStorage:', error);
                    // Try saving just a summary
                    try {
                        const summaryData = createDataSummary(collectedData);
                        const summaryJson = JSON.stringify(summaryData);
                        const sessionId = `morphcast_session_${new Date().toISOString().split('T')[0]}_${Date.now()}`;
                        localStorage.setItem(sessionId, summaryJson);
                        localStorage.setItem('morphcast_latest_session', summaryJson);
                        console.log('Summary data saved as fallback:', sessionId);
                        return sessionId;
                    } catch (summaryError) {
                        console.error('Failed to save even summary data:', summaryError);
                        return null;
                    }
                }
            }
            
            // Function to compress data for storage
            function compressDataForStorage(data) {
                const compressed = {};
                
                Object.keys(data).forEach(key => {
                    if (key === 'sessionInfo') {
                        compressed[key] = data[key];
                    } else if (Array.isArray(data[key])) {
                        // Keep only the last 100 entries for each module to reduce size
                        compressed[key] = data[key].slice(-100);
                    } else if (typeof data[key] === 'object' && data[key] !== null) {
                        compressed[key] = {};
                        Object.keys(data[key]).forEach(subKey => {
                            if (Array.isArray(data[key][subKey])) {
                                compressed[key][subKey] = data[key][subKey].slice(-50);
                            } else {
                                compressed[key][subKey] = data[key][subKey];
                            }
                        });
                    } else {
                        compressed[key] = data[key];
                    }
                });
                
                return compressed;
            }
            
            // Function to create a summary of the data
            function createDataSummary(data) {
                const summary = {
                    sessionInfo: data.sessionInfo,
                    summary: {
                        totalDataPoints: data.sessionInfo.totalDataPoints,
                        modules: {},
                        latestValues: getCurrentUIValues()
                    }
                };
                
                // Add summary for each module
                Object.keys(data).forEach(key => {
                    if (key !== 'sessionInfo') {
                        if (Array.isArray(data[key])) {
                            summary.summary.modules[key] = {
                                count: data[key].length,
                                latest: data[key].slice(-1)[0] || null
                            };
                        } else if (typeof data[key] === 'object' && data[key] !== null) {
                            summary.summary.modules[key] = {};
                            Object.keys(data[key]).forEach(subKey => {
                                if (Array.isArray(data[key][subKey])) {
                                    summary.summary.modules[key][subKey] = {
                                        count: data[key][subKey].length,
                                        latest: data[key][subKey].slice(-1)[0] || null
                                    };
                                }
                            });
                        }
                    }
                });
                
                return summary;
            }
            
            // Function to load data from localStorage
            function loadDataFromLocal(sessionId = null) {
                try {
                    const key = sessionId || 'morphcast_latest_session';
                    const savedData = localStorage.getItem(key);
                    
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        collectedData = { ...collectedData, ...parsedData };
                        console.log('Data loaded from localStorage:', key);
                        return parsedData;
                    } else {
                        console.log('No saved data found');
                        return null;
                    }
                } catch (error) {
                    console.error('Error loading data from localStorage:', error);
                    return null;
                }
            }
            
            // Function to export data as JSON file
            function exportDataAsJSON() {
                try {
                    const dataToExport = {
                        ...collectedData,
                        sessionInfo: {
                            ...collectedData.sessionInfo,
                            endTime: new Date().toISOString(),
                            exportTime: new Date().toISOString()
                        }
                    };
                    
                    const dataStr = JSON.stringify(dataToExport, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `morphcast-data-${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    console.log('Data exported as JSON file');
                    return true;
                } catch (error) {
                    console.error('Error exporting data:', error);
                    return false;
                }
            }
            
            // Function to get all saved sessions
            function getAllSavedSessions() {
                const sessions = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('morphcast_session_')) {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            sessions.push({
                                sessionId: key,
                                startTime: data.sessionInfo?.startTime,
                                endTime: data.sessionInfo?.endTime,
                                totalDataPoints: data.sessionInfo?.totalDataPoints || 0
                            });
                        } catch (error) {
                            console.error('Error parsing session data:', error);
                        }
                    }
                }
                return sessions.sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
            }
            
            // Function to delete a saved session
            function deleteSession(sessionId) {
                try {
                    localStorage.removeItem(sessionId);
                    console.log('Session deleted:', sessionId);
                    return true;
                } catch (error) {
                    console.error('Error deleting session:', error);
                    return false;
                }
            }
            
            // Function to start auto-save
            function startAutoSave() {
                if (autoSaveConfig.enabled && !autoSaveTimer) {
                    autoSaveTimer = setInterval(() => {
                        saveDataToLocal();
                    }, autoSaveConfig.interval);
                    console.log('Auto-save started');
                }
            }
            
            // Function to stop auto-save
            function stopAutoSave() {
                if (autoSaveTimer) {
                    clearInterval(autoSaveTimer);
                    autoSaveTimer = null;
                    console.log('Auto-save stopped');
                }
            }

            // Normalize MorphCast alarm payloads to determine ON/OFF state
            function isAlarmOn(detail) {
                const candidate = (detail && (detail.state ?? detail.output?.state ?? detail.value?.state ?? detail.on ?? detail.value ?? detail.output));
                if (typeof candidate === 'string') {
                    const normalized = candidate.toLowerCase();
                    return normalized === 'on' || normalized === 'true' || normalized === '1';
                }
                if (typeof candidate === 'boolean') return candidate;
                if (typeof candidate === 'number') return candidate > 0.5;
                return detail && detail.state === 'on';
            }
            
            // Function to request camera access
            async function requestCameraAccess() {
                try {
                    statusMessage.innerHTML = '<p>Requesting camera access...</p>';
                    
                    // Request camera permission
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user' 
                        } 
                    });
                    
                    // Display the camera feed
                    videoElement.srcObject = stream;
                    cameraPlaceholder.style.display = 'none';
                    statusMessage.innerHTML = '<p>Camera access granted. Starting analysis...</p>';
                    
                    // Initialize MorphCast after camera access is granted
                    initMorphCast();
                    
                } catch (error) {
                    console.error('Error accessing camera:', error);
                    statusMessage.innerHTML = `<p>Error: ${error.message}</p>`;
                    permissionBtn.textContent = 'Allow Camera Access';
                    isCameraActive = false;
                }
            }
            
            // Function to stop camera
            async function stopCamera() {
                if (stream) {
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    videoElement.srcObject = null;
                    cameraPlaceholder.style.display = 'block';
                }
                
                // Stop auto-save
                stopAutoSave();
                
                // Save final data
                collectedData.sessionInfo.endTime = new Date().toISOString();
                saveDataToLocal();
                
                if (statisticsUploader) {
                    // Stop statistics uploader
                    await statisticsUploader.stop();
                    statisticsUploader = null;
                }
                
                if (stopFunction) {
                    // Stop MorphCast analysis
                    await stopFunction();
                }
                startFunction = null;
                stopFunction = null;
                if (recomputeTimer) {
                    clearInterval(recomputeTimer);
                    recomputeTimer = null;
                }
            }
            
            // Function to initialize MorphCast with all modules
            async function initMorphCast() {
                try {
                    // Initialize statistics uploader
                    statisticsUploader = new MorphCastStatistics.StatisticsUploader(statsConfig);
                    
                    const { start, stop } = await CY.loader()
                        .licenseKey("sk75ffec7bbf60d0e38bea6af5f5e2fbd680b0c023201b")
                        .addModule(CY.modules().FACE_DETECTOR.name, {maxInputFrameSize: 320, smoothness: 0.83})
                        .addModule(CY.modules().FACE_POSE.name, {smoothness: 0.65})
                        .addModule(CY.modules().FACE_AGE.name, {rawOutput: false})
                        .addModule(CY.modules().FACE_EMOTION.name, {smoothness: 0.40})
                        .addModule(CY.modules().FACE_GENDER.name, {smoothness: 0.95, threshold: 0.70})
                        .addModule(CY.modules().FACE_FEATURES.name, {smoothness: 0.90, showAll: false})
                        .addModule(CY.modules().FACE_AROUSAL_VALENCE.name, {smoothness: 0.70})
                        .addModule(CY.modules().FACE_ATTENTION.name, {smoothness: 0.83})
                        .addModule(CY.modules().FACE_WISH.name, {smoothness: 0.80})
                        .addModule(CY.modules().FACE_POSITIVITY.name, {smoothness: 0.40, gain: 2, angle: 17})
                        .addModule(CY.modules().DATA_AGGREGATOR.name, {initialWaitMs: 2000, periodMs: 1000})
                        .addModule(CY.modules().ALARM_MORE_FACES.name, {timeWindowMs: 2500, initialToleranceMs: 800, threshold: 0.25})
                        .addModule(CY.modules().ALARM_NO_FACE.name, {timeWindowMs: 2500, initialToleranceMs: 800, threshold: 0.40})
                        .addModule(CY.modules().ALARM_LOW_ATTENTION.name, {timeWindowMs: 5000, initialToleranceMs: 7000, threshold: 0.33})
                        .load();
                    
                    startFunction = start;
                    stopFunction = stop;
                    
                    // Start both MorphCast and statistics
                    await start();
                    await statisticsUploader.start();
                    
                    // Initialize session info
                    collectedData.sessionInfo.startTime = new Date().toISOString();
                    
                    // Start auto-save
                    startAutoSave();
                    
                    isCameraActive = true;
                    permissionBtn.textContent = 'Stop Camera';
                    statusMessage.innerHTML = '<p>Analysis in progress. Try making different facial expressions.</p>';
                    
                    // Begin periodic debounce evaluation to avoid flicker
                    if (recomputeTimer) clearInterval(recomputeTimer);
                    recomputeTimer = setInterval(recomputeDesiredAlert, 200);
                    
                    // Auto-stop after configured time
                    setTimeout(async () => {
                        if (statisticsUploader) {
                            await statisticsUploader.stop();
                        }
                        if (stopFunction) {
                            await stopFunction();
                        }
                    }, statsConfig.stopAfter);
                    
                } catch (error) {
                    console.error('Error initializing MorphCast:', error);
                    statusMessage.innerHTML = '<p>Error starting analysis. Please try again.</p>';
                    permissionBtn.textContent = 'Allow Camera Access';
                    isCameraActive = false;
                }
            }
            
            // Event listeners for all MorphCast modules
            window.addEventListener(CY.modules().FACE_DETECTOR.eventName, (evt) => {
                console.log('FACE_DETECTOR result', evt.detail);
                collectLearningData('FACE_DETECTOR', evt.detail);
                
                const facesCount = evt.detail.totalFaces || 0;
                document.getElementById('facesValue').textContent = facesCount;
                
                // Show popup and play sound if no faces detected
                if (facesCount === 0) {
                    showAlert('Your Face is Not Detected', 'Please position yourself in front of the camera for analysis.');
                    playNoFaceSound();
                } else if (facesCount >= 1) {
                    // Hide popup if faces are detected
                    hideAlert();
                }
            });
            
            window.addEventListener(CY.modules().FACE_POSE.eventName, (evt) => {
                console.log('FACE_POSE result', evt.detail);
                collectData('facePose', evt.detail);
                
                if (evt.detail.output && evt.detail.output.pose) {
                    const pose = evt.detail.output.pose;
                    document.getElementById('pitchValue').textContent = pose.pitch ? pose.pitch.toFixed(2) : '-';
                    document.getElementById('rollValue').textContent = pose.roll ? pose.roll.toFixed(2) : '-';
                    document.getElementById('yawValue').textContent = pose.yaw ? pose.yaw.toFixed(2) : '-';
                }
            });
            
            window.addEventListener(CY.modules().FACE_AGE.eventName, (evt) => {
                console.log('FACE_AGE result', evt.detail);
                collectData('faceAge', evt.detail);
                
                if (evt.detail.output && evt.detail.output.age) {
                    const age = evt.detail.output.age;
                    document.getElementById('ageUnder18').textContent = age['_-18'] ? (age['_-18'] * 100).toFixed(1) + '%' : '-';
                    document.getElementById('age18to35').textContent = age['18-35'] ? (age['18-35'] * 100).toFixed(1) + '%' : '-';
                    document.getElementById('age35to51').textContent = age['35-51'] ? (age['35-51'] * 100).toFixed(1) + '%' : '-';
                    document.getElementById('ageOver51').textContent = age['51-_'] ? (age['51-_'] * 100).toFixed(1) + '%' : '-';
                    
                    if (evt.detail.output.numericAge) {
                        document.getElementById('ageValue').textContent = Math.round(evt.detail.output.numericAge);
                    }
                }
            });
            
            window.addEventListener(CY.modules().FACE_EMOTION.eventName, (evt) => {
                console.log('FACE_EMOTION result', evt.detail);
                collectLearningData('FACE_EMOTION', evt.detail);
                
                if (evt.detail.output && evt.detail.output.emotion) {
                    const emotions = evt.detail.output.emotion;
                    updateEmotion('happiness', emotions.Happy || 0);
                    updateEmotion('sadness', emotions.Sad || 0);
                    updateEmotion('anger', emotions.Angry || 0);
                    updateEmotion('surprise', emotions.Surprise || 0);
                    updateEmotion('fear', emotions.Fear || 0);
                    updateEmotion('disgust', emotions.Disgust || 0);
                    updateEmotion('neutral', emotions.Neutral || 0);
                }
            });
            
            window.addEventListener(CY.modules().FACE_GENDER.eventName, (evt) => {
                console.log('FACE_GENDER result', evt.detail);
                collectData('faceGender', evt.detail);
                
                if (evt.detail.output && evt.detail.output.gender) {
                    const gender = evt.detail.output.gender;
                    document.getElementById('genderMale').textContent = gender.Male ? (gender.Male * 100).toFixed(1) + '%' : '-';
                    document.getElementById('genderFemale').textContent = gender.Female ? (gender.Female * 100).toFixed(1) + '%' : '-';
                    
                    if (evt.detail.output.mostConfident) {
                        document.getElementById('genderValue').textContent = evt.detail.output.mostConfident;
                    }
                }
            });
            
            window.addEventListener(CY.modules().FACE_FEATURES.eventName, (evt) => {
                console.log('FACE_FEATURES result', evt.detail);
                collectData('faceFeatures', evt.detail);
                
                if (evt.detail.output && evt.detail.output.features) {
                    const features = evt.detail.output.features;
                    updateFacialFeatures(features);
                }
            });
            
            window.addEventListener(CY.modules().FACE_AROUSAL_VALENCE.eventName, (evt) => {
                console.log('FACE_AROUSAL_VALENCE result', evt.detail);
                collectLearningData('FACE_AROUSAL_VALENCE', evt.detail);
                
                if (evt.detail.output) {
                    document.getElementById('arousalValue').textContent = evt.detail.output.arousal ? evt.detail.output.arousal.toFixed(2) : '-';
                    document.getElementById('valenceValue').textContent = evt.detail.output.valence ? evt.detail.output.valence.toFixed(2) : '-';
                }
            });
            
            window.addEventListener(CY.modules().FACE_ATTENTION.eventName, (evt) => {
                console.log('FACE_ATTENTION result', evt.detail);
                collectLearningData('FACE_ATTENTION', evt.detail);
                
                if (evt.detail.output) {
                    document.getElementById('attentionValue').textContent = evt.detail.output.attention ? (evt.detail.output.attention * 100).toFixed(0) + '%' : '-';
                }
            });
            
            window.addEventListener(CY.modules().FACE_WISH.eventName, (evt) => {
                console.log('FACE_WISH result', evt.detail);
                collectData('faceWish', evt.detail);
                
                if (evt.detail.output) {
                    document.getElementById('wishValue').textContent = evt.detail.output.wish ? (evt.detail.output.wish * 100).toFixed(0) + '%' : '-';
                }
            });
            
            window.addEventListener(CY.modules().FACE_POSITIVITY.eventName, (evt) => {
                console.log('FACE_POSITIVITY result', evt.detail);
                collectData('facePositivity', evt.detail);
                
                if (evt.detail.output) {
                    document.getElementById('positivityValue').textContent = evt.detail.output.positivity ? (evt.detail.output.positivity * 100).toFixed(0) + '%' : '-';
                }
            });
            
            window.addEventListener(CY.modules().EVENT_BARRIER.eventName, (evt) => {
                console.log('EVENT_BARRIER result', evt.detail);
                collectData('eventBarrier', evt.detail);
            });
            
            window.addEventListener(CY.modules().DATA_AGGREGATOR.eventName, (evt) => {
                console.log('DATA_AGGREGATOR result', evt.detail);
                collectData('dataAggregator', evt.detail);
                // Use aggregator data as fallback for any missing values
            });
            
            // Listen for alarm events
            let alarmManyFacesOn = false;
            let alarmNoFaceOn = false;
            let alarmLowAttentionOn = false;
            let desiredAlertType = null;
            let visibleAlertType = null;
            let desiredSinceTs = 0;
            const SHOW_DELAY_MS = 700;
            const HIDE_DELAY_MS = 900;

            function recomputeDesiredAlert() {
                const nextDesired = alarmManyFacesOn ? 'many' : (alarmNoFaceOn ? 'no' : (alarmLowAttentionOn ? 'attention' : null));
                const now = Date.now();
                if (nextDesired !== desiredAlertType) {
                    desiredAlertType = nextDesired;
                    desiredSinceTs = now;
                }
                
                const stableFor = now - desiredSinceTs;
                if (visibleAlertType !== desiredAlertType) {
                    if (desiredAlertType && stableFor >= SHOW_DELAY_MS) {
                        if (desiredAlertType === 'many') {
                            showAlert('Multiple Faces Detected', 'Please ensure only one person is in the frame for accurate analysis.', '👥');
                        } else if (desiredAlertType === 'no') {
                            showAlert('No Face Detected', 'Please position yourself in front of the camera for analysis.', '🙈');
                        } else if (desiredAlertType === 'attention') {
                            showAlert('Low Attention Detected', 'Please focus on the camera for better analysis results.', '👀');
                        }
                        visibleAlertType = desiredAlertType;
                    } else if (!desiredAlertType && stableFor >= HIDE_DELAY_MS) {
                        hideAlert();
                        visibleAlertType = null;
                    }
                }
            }

            window.addEventListener(CY.modules().ALARM_MORE_FACES.eventName, (evt) => {
                console.log('ALARM_MORE_FACES result', evt.detail);
                collectData('alarms.moreFaces', evt.detail);
                alarmManyFacesOn = !!isAlarmOn(evt.detail);
                recomputeDesiredAlert();
            });
            
            window.addEventListener(CY.modules().ALARM_NO_FACE.eventName, (evt) => {
                console.log('ALARM_NO_FACE result', evt.detail);
                collectData('alarms.noFace', evt.detail);
                alarmNoFaceOn = !!isAlarmOn(evt.detail);
                recomputeDesiredAlert();
            });
            
            window.addEventListener(CY.modules().ALARM_LOW_ATTENTION.eventName, (evt) => {
                console.log('ALARM_LOW_ATTENTION result', evt.detail);
                collectData('alarms.lowAttention', evt.detail);
                alarmLowAttentionOn = !!isAlarmOn(evt.detail);
                recomputeDesiredAlert();
            });
            
            // Function to update UI with emotion data
            function updateEmotion(emotion, value) {
                const percentage = Math.round(value * 100);
                document.getElementById(`${emotion}Value`).textContent = `${percentage}%`;
                document.getElementById(`${emotion}Bar`).style.width = `${percentage}%`;
            }
            
            // Function to update facial features display
            function updateFacialFeatures(features) {
                // Clear previous features
                facialFeaturesContainer.innerHTML = '';
                
                // Show only features with probability > 20%
                const threshold = 0.2;
                const featureEntries = Object.entries(features);
                
                // Sort by probability (descending)
                featureEntries.sort((a, b) => b[1] - a[1]);
                
                // Display top features
                for (const [feature, probability] of featureEntries) {
                    if (probability > threshold) {
                        const featureItem = document.createElement('div');
                        featureItem.className = 'feature-item';
                        
                        const featureLabel = document.createElement('div');
                        featureLabel.className = 'feature-label';
                        featureLabel.textContent = feature;
                        
                        const featureValue = document.createElement('div');
                        featureValue.className = 'feature-value';
                        featureValue.textContent = (probability * 100).toFixed(1) + '%';
                        
                        featureItem.appendChild(featureLabel);
                        featureItem.appendChild(featureValue);
                        facialFeaturesContainer.appendChild(featureItem);
                    }
                }
                
                // If no features above threshold, show message
                if (facialFeaturesContainer.children.length === 0) {
                    facialFeaturesContainer.innerHTML = '<div class="feature-item">No significant facial features detected</div>';
                }
            }
            
            // Handle permission button click
            permissionBtn.addEventListener('click', function() {
                if (!isCameraActive) {
                    requestCameraAccess();
                } else {
                    // Stop the camera
                    stopCamera();
                    permissionBtn.textContent = 'Allow Camera Access';
                    statusMessage.innerHTML = '<p>Camera stopped. Click button to start again.</p>';
                    isCameraActive = false;
                    hideAlert();
                }
            });
            
            // Close alert when button is clicked
            alertButton.addEventListener('click', hideAlert);
            
            // Data control button event listeners
            document.getElementById('saveDataBtn').addEventListener('click', () => {
                const sessionId = saveDataToLocal();
                if (sessionId) {
                    showAlert('Data Saved', `Data saved successfully! Session ID: ${sessionId.split('_').pop()}`, '💾');
                } else {
                    showAlert('Save Error', 'Failed to save data. Check console for details.', '❌');
                }
            });
            
            document.getElementById('loadDataBtn').addEventListener('click', () => {
                const loadedData = loadDataFromLocal();
                if (loadedData) {
                    showAlert('Data Loaded', `Loaded ${loadedData.sessionInfo?.totalDataPoints || 0} data points from latest session`, '📂');
                } else {
                    showAlert('Load Error', 'No saved data found or failed to load data.', '❌');
                }
            });
            
            document.getElementById('exportDataBtn').addEventListener('click', () => {
                const success = exportDataAsJSON();
                if (success) {
                    showAlert('Export Complete', 'Data exported as JSON file successfully!', '📁');
                } else {
                    showAlert('Export Error', 'Failed to export data. Check console for details.', '❌');
                }
            });
            
            document.getElementById('clearDataBtn').addEventListener('click', () => {
                if (confirm('Are you sure you want to clear all collected data? This action cannot be undone.')) {
                    clearData();
                    showAlert('Data Cleared', 'All collected data has been cleared.', '🗑️');
                }
            });
            
            document.getElementById('startSessionBtn').addEventListener('click', startLearningSession);
            
            document.getElementById('debugDataBtn').addEventListener('click', () => {
                console.log('=== RAW DATA DEBUG ===');
                console.log('Session Info:', collectedData.sessionInfo);
                console.log('Data Counts:', {
                    faceAttention: collectedData.faceAttention.length,
                    faceArousalValence: collectedData.faceArousalValence.length,
                    faceEmotion: collectedData.faceEmotion.length,
                    faceDetector: collectedData.faceDetector.length
                });
                console.log('Raw Data:', collectedData);
                
                const totalPoints = collectedData.faceAttention.length + collectedData.faceArousalValence.length + 
                                  collectedData.faceEmotion.length + collectedData.faceDetector.length;
                showAlert('Raw Data Debug', `Check console for data details. Total points: ${totalPoints}`, '🐛');
            });
            
            // Initialize facial features container
            facialFeaturesContainer.innerHTML = '<div class="feature-item">Waiting for facial features data...</div>';
        });
    </script>
</body>
</html>