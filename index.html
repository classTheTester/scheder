<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MorphCast Emotion Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
            transition: background 0.5s ease;
        }
        
        body.bright-mode {
            background: #ffffff;
        }
        
        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .camera-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            z-index: 1;
        }
        
        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .camera-placeholder {
            text-align: center;
            color: #ccc;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        
        .camera-placeholder i {
            font-size: 64px;
            margin-bottom: 15px;
            display: block;
        }
        
        .overlay-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }
        
        .tile {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            cursor: move;
            user-select: none;
            position: absolute;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            pointer-events: auto;
            min-width: 160px;
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .bright-mode .tile {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #333;
        }
        
        .tile:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }
        
        .tile.dragging {
            opacity: 0.9;
            z-index: 100;
        }
        
        .tile-title {
            font-size: 1.1rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .bright-mode .tile-title {
            border-bottom: 1px solid rgba(0, 0, 0, 0.2);
            color: #333;
        }
        
        .tile-content {
            font-size: 0.95rem;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .metric-label {
            opacity: 0.8;
        }
        
        .bright-mode .metric-label {
            color: #666;
        }
        
        .metric-value {
            font-weight: bold;
        }
        
        .bright-mode .metric-value {
            color: #333;
        }
        
        .emotion-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .bright-mode .emotion-bar {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .emotion-fill {
            height: 100%;
            background: linear-gradient(to right, #ff9a9e 0%, #fad0c4 99%, #fad0c4 100%);
            border-radius: 4px;
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            pointer-events: auto;
        }
        
        .control-btn {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .bright-mode .control-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .bright-mode-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            pointer-events: auto;
        }
        
        .bright-mode .bright-mode-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }
        
        .bright-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        .status {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            max-width: 300px;
            pointer-events: auto;
        }
        
        .bright-mode .status {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }
        
        .alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .alert-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .alert-popup {
            background: linear-gradient(to bottom, #2c3e50, #4a6491);
            border-radius: 15px;
            padding: 30px;
            width: 90%;
            max-width: 450px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            transform: translateY(20px);
            transition: transform 0.4s ease;
        }
        
        .alert-overlay.active .alert-popup {
            transform: translateY(0);
        }
        
        .alert-icon {
            font-size: 60px;
            margin-bottom: 20px;
        }
        
        .alert-title {
            font-size: 24px;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .alert-message {
            font-size: 18px;
            margin-bottom: 25px;
            line-height: 1.5;
            color: #e0e0e0;
        }
        
        .alert-button {
            background: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .alert-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        @media (max-width: 768px) {
            .tile {
                min-width: 140px;
                padding: 12px;
            }
            
            .control-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            .tile {
                min-width: 120px;
                padding: 10px;
                font-size: 0.9rem;
            }
            
            .controls {
                bottom: 10px;
            }
            
            .control-btn {
                padding: 8px 12px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="camera-container">
            <video id="videoElement" autoplay playsinline></video>
            <div class="camera-placeholder" id="cameraPlaceholder">
                <i>üì∑</i>
                <p>Camera access required</p>
            </div>
        </div>
        
        <div class="overlay-container" id="overlayContainer">
            <!-- Tiles will be added here dynamically -->
        </div>
        
        <div class="controls">
            <button id="permissionBtn" class="control-btn">
                <i class="fas fa-camera"></i> Enable Camera
            </button>
            <button id="stopBtn" class="control-btn" disabled>
                <i class="fas fa-stop"></i> Stop
            </button>
        </div>
        
        <button id="brightModeBtn" class="bright-mode-btn">Bright Mode</button>
        
        <div class="status" id="statusMessage">
            <p>Waiting for camera access to begin analysis...</p>
        </div>
    </div>

    <!-- Alert Popup -->
    <div class="alert-overlay" id="alertOverlay">
        <div class="alert-popup">
            <div class="alert-icon" id="alertIcon">‚ö†Ô∏è</div>
            <h2 class="alert-title" id="alertTitle">Alert</h2>
            <p class="alert-message" id="alertMessage">This is an alert message</p>
            <button class="alert-button" id="alertButton">OK</button>
        </div>
    </div>

    <!-- Font Awesome for icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>

    <!-- MorphCast SDK -->
    <script src="https://sdk.morphcast.com/mphtools/v1.1/mphtools.js" data-config="cameraPrivacyPopup, compatibilityUI, compatibilityAutoCheck"></script>
    <script src="https://ai-sdk.morphcast.com/v1.16/ai-sdk.js"></script>
    <script type="module" src="https://sdk.morphcast.com/mphoverlay/v0.1/mph-ai-overlaey.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const permissionBtn = document.getElementById('permissionBtn');
            const stopBtn = document.getElementById('stopBtn');
            const videoElement = document.getElementById('videoElement');
            const cameraPlaceholder = document.getElementById('cameraPlaceholder');
            const statusMessage = document.getElementById('statusMessage');
            const alertOverlay = document.getElementById('alertOverlay');
            const alertIcon = document.getElementById('alertIcon');
            const alertTitle = document.getElementById('alertTitle');
            const alertMessage = document.getElementById('alertMessage');
            const alertButton = document.getElementById('alertButton');
            const brightModeBtn = document.getElementById('brightModeBtn');
            const overlayContainer = document.getElementById('overlayContainer');
            const body = document.body;
            
            let isCameraActive = false;
            let stream = null;
            let startFunction = null;
            let stopFunction = null;
            let currentAlert = null;
            let recomputeTimer = null;
            let isBrightMode = false;
            
            // Draggable functionality for tiles
            let draggedElement = null;
            let offsetX = 0;
            let offsetY = 0;
            
            // Create tiles with initial positions
            const tiles = [
                { 
                    id: 'attentionTile', 
                    title: 'Attention & Focus', 
                    metrics: [
                        { id: 'attentionValue', label: 'Attention', value: '-' },
                        { id: 'arousalValue', label: 'Arousal', value: '-' },
                        { id: 'valenceValue', label: 'Valence', value: '-' }
                    ],
                    top: '20px', 
                    right: '20px' 
                },
                { 
                    id: 'emotionTile', 
                    title: 'Emotions', 
                    metrics: [
                        { id: 'happinessValue', label: 'Happiness', value: '0%', bar: true },
                        { id: 'sadnessValue', label: 'Sadness', value: '0%', bar: true },
                        { id: 'angerValue', label: 'Anger', value: '0%', bar: true },
                        { id: 'surpriseValue', label: 'Surprise', value: '0%', bar: true }
                    ],
                    top: '20px', 
                    right: '220px' 
                },
                { 
                    id: 'faceDetailsTile', 
                    title: 'Face Details', 
                    metrics: [
                        { id: 'ageValue', label: 'Age', value: '-' },
                        { id: 'genderValue', label: 'Gender', value: '-' },
                        { id: 'facesValue', label: 'Faces', value: '-' }
                    ],
                    top: '220px', 
                    right: '20px' 
                },
                { 
                    id: 'facePoseTile', 
                    title: 'Head Position', 
                    metrics: [
                        { id: 'pitchValue', label: 'Pitch', value: '-' },
                        { id: 'rollValue', label: 'Roll', value: '-' },
                        { id: 'yawValue', label: 'Yaw', value: '-' }
                    ],
                    top: '220px', 
                    right: '220px' 
                },
                { 
                    id: 'ageProbabilityTile', 
                    title: 'Age Probability', 
                    metrics: [
                        { id: 'ageUnder18', label: 'Under 18', value: '-' },
                        { id: 'age18to35', label: '18-35', value: '-' },
                        { id: 'age35to51', label: '35-51', value: '-' },
                        { id: 'ageOver51', label: 'Over 51', value: '-' }
                    ],
                    top: '420px', 
                    right: '20px' 
                },
                { 
                    id: 'genderProbabilityTile', 
                    title: 'Gender Probability', 
                    metrics: [
                        { id: 'genderMale', label: 'Male', value: '-' },
                        { id: 'genderFemale', label: 'Female', value: '-' }
                    ],
                    top: '420px', 
                    right: '220px' 
                },
                { 
                    id: 'additionalMetricsTile', 
                    title: 'Additional Metrics', 
                    metrics: [
                        { id: 'positivityValue', label: 'Positivity', value: '-' },
                        { id: 'wishValue', label: 'Wish', value: '-' }
                    ],
                    top: '520px', 
                    right: '20px' 
                },
                { 
                    id: 'facialFeaturesTile', 
                    title: 'Facial Features', 
                    metrics: [],
                    top: '520px', 
                    right: '220px',
                    isFeatureTile: true
                }
            ];
            
            // Create and position tiles
            tiles.forEach(tile => {
                const tileElement = document.createElement('div');
                tileElement.id = tile.id;
                tileElement.className = 'tile';
                tileElement.style.top = tile.top;
                tileElement.style.right = tile.right;
                
                let contentHTML = `<div class="tile-title">${tile.title}</div>`;
                
                if (tile.isFeatureTile) {
                    contentHTML += `<div class="feature-grid" id="facialFeaturesContainer"></div>`;
                } else {
                    tile.metrics.forEach(metric => {
                        contentHTML += `
                            <div class="metric">
                                <span class="metric-label">${metric.label}:</span>
                                <span class="metric-value" id="${metric.id}">${metric.value}</span>
                            </div>
                        `;
                        if (metric.bar) {
                            contentHTML += `
                                <div class="emotion-bar">
                                    <div class="emotion-fill" id="${metric.id.replace('Value', 'Bar')}"></div>
                                </div>
                            `;
                        }
                    });
                }
                
                tileElement.innerHTML = contentHTML;
                overlayContainer.appendChild(tileElement);
                
                // Make tile draggable
                tileElement.addEventListener('mousedown', startDrag);
                tileElement.addEventListener('touchstart', startDrag, { passive: false });
            });
            
            function startDrag(e) {
                e.preventDefault();
                draggedElement = this;
                
                if (e.type === 'mousedown') {
                    offsetX = e.clientX - draggedElement.getBoundingClientRect().left;
                    offsetY = e.clientY - draggedElement.getBoundingClientRect().top;
                    document.addEventListener('mousemove', onDrag);
                    document.addEventListener('mouseup', stopDrag);
                } else if (e.type === 'touchstart') {
                    const touch = e.touches[0];
                    offsetX = touch.clientX - draggedElement.getBoundingClientRect().left;
                    offsetY = touch.clientY - draggedElement.getBoundingClientRect().top;
                    document.addEventListener('touchmove', onDrag, { passive: false });
                    document.addEventListener('touchend', stopDrag);
                }
                
                draggedElement.classList.add('dragging');
            }
            
            function onDrag(e) {
                if (!draggedElement) return;
                
                e.preventDefault();
                let clientX, clientY;
                
                if (e.type === 'mousemove') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else if (e.type === 'touchmove') {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                }
                
                // Calculate new position
                const x = clientX - offsetX;
                const y = clientY - offsetY;
                
                // Apply new position
                draggedElement.style.left = `${x}px`;
                draggedElement.style.right = 'auto';
                draggedElement.style.top = `${y}px`;
            }
            
            function stopDrag() {
                if (draggedElement) {
                    draggedElement.classList.remove('dragging');
                    draggedElement = null;
                }
                
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchmove', onDrag);
                document.removeEventListener('touchend', stopDrag);
            }
            
            // Bright mode toggle
            brightModeBtn.addEventListener('click', function() {
                isBrightMode = !isBrightMode;
                body.classList.toggle('bright-mode', isBrightMode);
                brightModeBtn.textContent = isBrightMode ? 'Dark Mode' : 'Bright Mode';
            });
            
            // Configure privacy popup text
            MphTools.CameraPrivacyPopup.setText({
                "title": "Allow us to use your camera",
                "description": "This experience is designed to be viewed with your camera on. The next screen will ask your consent to access data from your camera.",
                "url": "https://example.com/privacy-policy"
            });
            
            // Function to show alert popup
            function showAlert(title, message, icon = '‚ö†Ô∏è') {
                if (currentAlert) {
                    clearTimeout(currentAlert);
                    currentAlert = null;
                }
                alertIcon.textContent = icon;
                alertTitle.textContent = title;
                alertMessage.textContent = message;
                alertOverlay.classList.add('active');
                
                // Auto-hide after 5 seconds
                currentAlert = setTimeout(hideAlert, 5000);
            }
            
            // Function to hide alert popup
            function hideAlert() {
                alertOverlay.classList.remove('active');
                if (currentAlert) {
                    clearTimeout(currentAlert);
                    currentAlert = null;
                }
            }

            // Normalize MorphCast alarm payloads to determine ON/OFF state
            function isAlarmOn(detail) {
                const candidate = (detail && (detail.state ?? detail.output?.state ?? detail.value?.state ?? detail.on ?? detail.value ?? detail.output));
                if (typeof candidate === 'string') {
                    const normalized = candidate.toLowerCase();
                    return normalized === 'on' || normalized === 'true' || normalized === '1';
                }
                if (typeof candidate === 'boolean') return candidate;
                if (typeof candidate === 'number') return candidate > 0.5;
                return detail && detail.state === 'on';
            }
            
            // Function to request camera access
            async function requestCameraAccess() {
                try {
                    statusMessage.innerHTML = '<p>Requesting camera access...</p>';
                    
                    // Request camera permission
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user' 
                        } 
                    });
                    
                    // Display the camera feed
                    videoElement.srcObject = stream;
                    cameraPlaceholder.style.display = 'none';
                    statusMessage.innerHTML = '<p>Camera access granted. Starting analysis...</p>';
                    
                    // Initialize MorphCast after camera access is granted
                    initMorphCast();
                    
                } catch (error) {
                    console.error('Error accessing camera:', error);
                    statusMessage.innerHTML = `<p>Error: ${error.message}</p>`;
                    permissionBtn.textContent = 'Enable Camera';
                    isCameraActive = false;
                }
            }
            
            // Function to stop camera
            function stopCamera() {
                if (stream) {
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    videoElement.srcObject = null;
                    cameraPlaceholder.style.display = 'block';
                }
                
                if (stopFunction) {
                    // Stop MorphCast analysis
                    stopFunction();
                }
                startFunction = null;
                stopFunction = null;
                if (recomputeTimer) {
                    clearInterval(recomputeTimer);
                    recomputeTimer = null;
                }
            }
            
            // Function to initialize MorphCast with all modules
            function initMorphCast() {
                CY.loader()
                    .licenseKey("sk75ffec7bbf60d0e38bea6af5f5e2fbd680b0c023201b")
                    .addModule(CY.modules().FACE_DETECTOR.name, {maxInputFrameSize: 320, smoothness: 0.83})
                    .addModule(CY.modules().FACE_POSE.name, {smoothness: 0.65})
                    .addModule(CY.modules().FACE_AGE.name, {rawOutput: false})
                    .addModule(CY.modules().FACE_EMOTION.name, {smoothness: 0.40})
                    .addModule(CY.modules().FACE_GENDER.name, {smoothness: 0.95, threshold: 0.70})
                    .addModule(CY.modules().FACE_FEATURES.name, {smoothness: 0.90, showAll: true})
                    .addModule(CY.modules().FACE_AROUSAL_VALENCE.name, {smoothness: 0.70})
                    .addModule(CY.modules().FACE_ATTENTION.name, {smoothness: 0.83})
                    .addModule(CY.modules().FACE_WISH.name, {smoothness: 0.80})
                    .addModule(CY.modules().FACE_POSITIVITY.name, {smoothness: 0.40, gain: 2, angle: 17})
                    .addModule(CY.modules().ALARM_MORE_FACES.name, {timeWindowMs: 2500, initialToleranceMs: 800, threshold: 0.25})
                    .addModule(CY.modules().ALARM_NO_FACE.name, {timeWindowMs: 2500, initialToleranceMs: 800, threshold: 0.40})
                    .addModule(CY.modules().ALARM_LOW_ATTENTION.name, {timeWindowMs: 5000, initialToleranceMs: 7000, threshold: 0.33})
                    .load()
                    .then(({ start, stop }) => {
                        startFunction = start;
                        stopFunction = stop;
                        start();
                        isCameraActive = true;
                        permissionBtn.textContent = 'Stop Camera';
                        stopBtn.disabled = false;
                        statusMessage.innerHTML = '<p>Analysis in progress. Try making different facial expressions.</p>';
                        // Begin periodic debounce evaluation to avoid flicker
                        if (recomputeTimer) clearInterval(recomputeTimer);
                        recomputeTimer = setInterval(recomputeDesiredAlert, 200);
                    })
                    .catch(error => {
                        console.error('Error initializing MorphCast:', error);
                        statusMessage.innerHTML = '<p>Error starting analysis. Please try again.</p>';
                        permissionBtn.textContent = 'Enable Camera';
                        isCameraActive = false;
                    });
            }
            
            // Event listeners for all MorphCast modules
            window.addEventListener(CY.modules().FACE_DETECTOR.eventName, (evt) => {
                document.getElementById('facesValue').textContent = evt.detail.totalFaces || 0;
            });
            
            window.addEventListener(CY.modules().FACE_POSE.eventName, (evt) => {
                if (evt.detail.output && evt.detail.output.pose) {
                    const pose = evt.detail.output.pose;
                    document.getElementById('pitchValue').textContent = pose.pitch ? pose.pitch.toFixed(2) + '¬∞' : '-';
                    document.getElementById('rollValue').textContent = pose.roll ? pose.roll.toFixed(2) + '¬∞' : '-';
                    document.getElementById('yawValue').textContent = pose.yaw ? pose.yaw.toFixed(2) + '¬∞' : '-';
                }
            });
            
            window.addEventListener(CY.modules().FACE_AGE.eventName, (evt) => {
                if (evt.detail.output && evt.detail.output.age) {
                    const age = evt.detail.output.age;
                    document.getElementById('ageUnder18').textContent = age['_-18'] ? (age['_-18'] * 100).toFixed(1) + '%' : '-';
                    document.getElementById('age18to35').textContent = age['18-35'] ? (age['18-35'] * 100).toFixed(1) + '%' : '-';
                    document.getElementById('age35to51').textContent = age['35-51'] ? (age['35-51'] * 100).toFixed(1) + '%' : '-';
                    document.getElementById('ageOver51').textContent = age['51-_'] ? (age['51-_'] * 100).toFixed(1) + '%' : '-';
                    
                    if (evt.detail.output.numericAge) {
                        document.getElementById('ageValue').textContent = Math.round(evt.detail.output.numericAge);
                    }
                }
            });
            
            window.addEventListener(CY.modules().FACE_EMOTION.eventName, (evt) => {
                if (evt.detail.output && evt.detail.output.emotion) {
                    const emotions = evt.detail.output.emotion;
                    updateEmotion('happiness', emotions.Happy || 0);
                    updateEmotion('sadness', emotions.Sad || 0);
                    updateEmotion('anger', emotions.Angry || 0);
                    updateEmotion('surprise', emotions.Surprise || 0);
                }
            });
            
            window.addEventListener(CY.modules().FACE_GENDER.eventName, (evt) => {
                if (evt.detail.output && evt.detail.output.gender) {
                    const gender = evt.detail.output.gender;
                    document.getElementById('genderMale').textContent = gender.Male ? (gender.Male * 100).toFixed(1) + '%' : '-';
                    document.getElementById('genderFemale').textContent = gender.Female ? (gender.Female * 100).toFixed(1) + '%' : '-';
                    
                    if (evt.detail.output.mostConfident) {
                        document.getElementById('genderValue').textContent = evt.detail.output.mostConfident;
                    }
                }
            });
            
            window.addEventListener(CY.modules().FACE_FEATURES.eventName, (evt) => {
                if (evt.detail.output && evt.detail.output.features) {
                    const features = evt.detail.output.features;
                    updateFacialFeatures(features);
                }
            });
            
            window.addEventListener(CY.modules().FACE_AROUSAL_VALENCE.eventName, (evt) => {
                if (evt.detail.output) {
                    document.getElementById('arousalValue').textContent = evt.detail.output.arousal ? evt.detail.output.arousal.toFixed(2) : '-';
                    document.getElementById('valenceValue').textContent = evt.detail.output.valence ? evt.detail.output.valence.toFixed(2) : '-';
                }
            });
            
            window.addEventListener(CY.modules().FACE_ATTENTION.eventName, (evt) => {
                if (evt.detail.output) {
                    document.getElementById('attentionValue').textContent = evt.detail.output.attention ? (evt.detail.output.attention * 100).toFixed(0) + '%' : '-';
                }
            });
            
            window.addEventListener(CY.modules().FACE_WISH.eventName, (evt) => {
                if (evt.detail.output) {
                    document.getElementById('wishValue').textContent = evt.detail.output.wish ? (evt.detail.output.wish * 100).toFixed(0) + '%' : '-';
                }
            });
            
            window.addEventListener(CY.modules().FACE_POSITIVITY.eventName, (evt) => {
                if (evt.detail.output) {
                    document.getElementById('positivityValue').textContent = evt.detail.output.positivity ? (evt.detail.output.positivity * 100).toFixed(0) + '%' : '-';
                }
            });
            
            // Listen for alarm events
            let alarmManyFacesOn = false;
            let alarmNoFaceOn = false;
            let alarmLowAttentionOn = false;
            let desiredAlertType = null;
            let visibleAlertType = null;
            let desiredSinceTs = 0;
            const SHOW_DELAY_MS = 700;
            const HIDE_DELAY_MS = 900;

            function recomputeDesiredAlert() {
                const nextDesired = alarmManyFacesOn ? 'many' : (alarmNoFaceOn ? 'no' : (alarmLowAttentionOn ? 'attention' : null));
                const now = Date.now();
                if (nextDesired !== desiredAlertType) {
                    desiredAlertType = nextDesired;
                    desiredSinceTs = now;
                }
                
                const stableFor = now - desiredSinceTs;
                if (visibleAlertType !== desiredAlertType) {
                    if (desiredAlertType && stableFor >= SHOW_DELAY_MS) {
                        if (desiredAlertType === 'many') {
                            showAlert('Multiple Faces Detected', 'Please ensure only one person is in the frame for accurate analysis.', 'üë•');
                        } else if (desiredAlertType === 'no') {
                            showAlert('No Face Detected', 'Please position yourself in front of the camera for analysis.', 'üôà');
                        } else if (desiredAlertType === 'attention') {
                            showAlert('Low Attention Detected', 'Please focus on the camera for better analysis results.', 'üëÄ');
                        }
                        visibleAlertType = desiredAlertType;
                    } else if (!desiredAlertType && stableFor >= HIDE_DELAY_MS) {
                        hideAlert();
                        visibleAlertType = null;
                    }
                }
            }

            window.addEventListener(CY.modules().ALARM_MORE_FACES.eventName, (evt) => {
                alarmManyFacesOn = !!isAlarmOn(evt.detail);
                recomputeDesiredAlert();
            });
            
            window.addEventListener(CY.modules().ALARM_NO_FACE.eventName, (evt) => {
                alarmNoFaceOn = !!isAlarmOn(evt.detail);
                recomputeDesiredAlert();
            });
            
            window.addEventListener(CY.modules().ALARM_LOW_ATTENTION.eventName, (evt) => {
                alarmLowAttentionOn = !!isAlarmOn(evt.detail);
                recomputeDesiredAlert();
            });
            
            // Function to update UI with emotion data
            function updateEmotion(emotion, value) {
                const percentage = Math.round(value * 100);
                document.getElementById(`${emotion}Value`).textContent = `${percentage}%`;
                document.getElementById(`${emotion}Bar`).style.width = `${percentage}%`;
            }
            
            // Function to update facial features display
            function updateFacialFeatures(features) {
                const container = document.getElementById('facialFeaturesContainer');
                if (!container) return;
                
                // Clear previous features
                container.innerHTML = '';
                
                // Show only features with probability > 20%
                const threshold = 0.0;
                const featureEntries = Object.entries(features);
                
                // Sort by probability (descending)
                featureEntries.sort((a, b) => b[1] - a[1]);
                
                // Display top features
                for (const [feature, probability] of featureEntries) {
                    if (probability > threshold && 
            feature !== "Big Nose" && 
            feature !== "Hat" && 
            feature !== "Necktie") {
                        const featureItem = document.createElement('div');
                        featureItem.className = 'metric';
                        
                        const featureLabel = document.createElement('span');
                        featureLabel.className = 'metric-label';
                        featureLabel.textContent = feature;
                        
                        const featureValue = document.createElement('span');
                        featureValue.className = 'metric-value';
                        featureValue.textContent = (probability * 100).toFixed(1) + '%';
                        
                        featureItem.appendChild(featureLabel);
                        featureItem.appendChild(featureValue);
                        container.appendChild(featureItem);
                    }
                }
                
                // If no features above threshold, show message
                if (container.children.length === 0) {
                    container.innerHTML = '<div class="metric">No significant facial features detected</div>';
                }
            }
            
            // Handle permission button click
            permissionBtn.addEventListener('click', function() {
                if (!isCameraActive) {
                    requestCameraAccess();
                } else {
                    // Stop the camera
                    stopCamera();
                    permissionBtn.textContent = 'Enable Camera';
                    stopBtn.disabled = true;
                    statusMessage.innerHTML = '<p>Camera stopped. Click button to start again.</p>';
                    isCameraActive = false;
                    hideAlert();
                }
            });
            
            // Handle stop button click
            stopBtn.addEventListener('click', function() {
                if (isCameraActive) {
                    stopCamera();
                    permissionBtn.textContent = 'Enable Camera';
                    stopBtn.disabled = true;
                    statusMessage.innerHTML = '<p>Camera stopped. Click button to start again.</p>';
                    isCameraActive = false;
                    hideAlert();
                }
            });
            
            // Close alert when button is clicked
            alertButton.addEventListener('click', hideAlert);
        });
    </script>
</body>
</html>